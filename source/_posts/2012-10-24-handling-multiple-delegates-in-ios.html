--- 
categories: 
- ios
- ipad
- iphone
- objective-c
layout: post
published: true
permalink: /handling-multiple-delegates-in-ios/index.html
title: Handling multiple delegates in iOS
---
<p>Sometimes, the delegate pattern in iOS just doesn't fit with a class heirarchy or design, specifically when you find yourself wanting to assign multiple delegates to a single source. For these cases, the approach usually taken is to use the notification center. This is an approach I have used in the past, but it always felt like a cop-out. Instead, I decided to build a delegate proxy using an NSProxy subclass. It takes a list of target delegates, and operates on two simple rules:</p>
<ol>
<li>Messages with a void return type are sent to all target delegates</li>
<li>Messages with non-void return types are send to the <em>first delegate in the list which responds to the selector.</em></li>
</ol>
<p>This pattern seems to be effective in identifying which messages are informative (hey, something happened) and which messages are more complex interactions (how should I do this?). It worked well for my use case (UIScrollViewDelegate), and I'm really curious to see how well it works for other applications. Comment if you find some use for it! &nbsp;Podspec included for CocoaPods users.</p>
<p><a href="https://github.com/hoteltonight/HTDelegateProxy" title="HTDelegateProxy on GitHub" target="_blank">The class HTDelegateProxy is available here on GitHub.</a></p>
